"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[7022],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8031:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:1},r="Create Pulverized Components",s={unversionedId:"tutorial-basics/create-components",id:"tutorial-basics/create-components",title:"Create Pulverized Components",description:"In this tutorial we are going to create a simple pulverized application consisting of a device made up of the following",source:"@site/docs/tutorial-basics/create-components.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/create-components",permalink:"/pulverization-framework/docs/tutorial-basics/create-components",draft:!1,editUrl:"https://github.com/nicolasfara/pulverization-framework/tree/master/docsite/docs/tutorial-basics/create-components.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Tutorial - RabbitMQ platform",permalink:"/pulverization-framework/docs/category/tutorial---rabbitmq-platform"},next:{title:"Create Communicators",permalink:"/pulverization-framework/docs/tutorial-basics/create-communicator"}},l={},p=[{value:"Behaviour",id:"behaviour",level:2},{value:"State",id:"state",level:2},{value:"Communication",id:"communication",level:2},{value:"Sensors",id:"sensors",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"create-pulverized-components"},"Create Pulverized Components"),(0,o.kt)("p",null,"In this tutorial we are going to create a simple pulverized application consisting of a device made up of the following\ncomponents:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Behaviour")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Communication")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Sensors"))),(0,o.kt)("p",null,"The objective of the device is read a value through the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sensors")," component, elaborate that value through\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour"),"component and send the output via the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component to all the neighbours."),(0,o.kt)("p",null,'In this scenario we assume a "fully-connected topology" so that all the devices are connected to each other.'),(0,o.kt)("h2",{id:"behaviour"},"Behaviour"),(0,o.kt)("p",null,"In this scenario the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour")," do nothing especial; it compute an identity function of the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(state, neighboursComm, sensedValues) -> (state, communication)\n")),(0,o.kt)("p",null,"In this way, we take the ",(0,o.kt)("inlineCode",{parentName:"p"},"State"),", all the messages coming from the neighbours and generate a new communication to\npropagate to all the neighbours. The function returns the same state and the message generated.\nThe generated message contain the sensor value read from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sesnors")," component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class DeviceBehaviour : Behaviour<StateRepr, CommPayload, AllSensorsPayload, Unit, Unit> {\n  override val context: Context by inject()\n\n  override fun invoke(\n    state: StateRepr,\n    export: List<CommPayload>,\n    sensedValues: AllSensorsPayload,\n  ): BehaviourOutput<StateRepr, CommPayload, Unit, Unit> {\n    println("Neighbours info: $export")\n    val payload = CommPayload(context.id.show(), sensedValues.deviceSensor)\n    return BehaviourOutput(state, payload, Unit, Unit)\n  }\n}\n')),(0,o.kt)("p",null,"The creation of the behaviour is made via the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behavior")," interface which requires the definitions\nof several type variables. The first one define the shape of the state, in particular the type should implement the\ninterface ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRepresentation"),". The second generic represents the communication payload and the given type should\nimplement the ",(0,o.kt)("inlineCode",{parentName:"p"},"CommunicationPayload")," interface. Moving on, the third generic specifies how all the sensors values are\ncollected; in this type should be available all the sensed values. The last two type variable represent respectively the\nprescriptive actions and the function outcome. In this tutorial since we do not use any of this two parameters we leave\nthem empty."),(0,o.kt)("p",null,"The behaviour logic in implemented in the ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke()")," method. This method should return a ",(0,o.kt)("inlineCode",{parentName:"p"},"BehaviourOutput")," which consist\nof: a new state, the communication for the neighbours, prescriptive actions and an outcome."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Each ",(0,o.kt)("inlineCode",{parentName:"p"},"PulverizedComponent")," holds a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),". The context contains some information about the specific instance\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"LogicalDevice")," that the component belongs to. Different platform enrich the context with platform-specific\ninformation that could be exploited by the component or by the layers below.")),(0,o.kt)("h2",{id:"state"},"State"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," in this scenario is used as a demonstration only: it does not provide any contribution to the demo."),(0,o.kt)("p",null,"To define a new state we should, first of all, define how the state is composed. To do that is useful to define the\nrepresentation of the state through a ",(0,o.kt)("inlineCode",{parentName:"p"},"data class")," which implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRepresentation")," interface."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class StateRepr(val counter: Int) : StateRepresentation\n")),(0,o.kt)("p",null,"Once the state representation is defined we need to create the state component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class DeviceState : State<StateRepr> {\n  override val context: Context by inject()\n\n  private var internalState: StateRepr = StateRepr(0)\n\n  override fun get(): StateRepr = internalState\n\n  override fun update(newState: StateRepr): StateRepr {\n    val tmp = internalState\n    internalState = newState\n    return tmp\n  }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DeviceState")," implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," interface with requires a ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRepresentation")," and we give the data class\nalready created."),(0,o.kt)("p",null,"Only two methods are to be implemented ",(0,o.kt)("inlineCode",{parentName:"p"},"get()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"update()")," which respectively return the current state and update the\nstate with a new one."),(0,o.kt)("h2",{id:"communication"},"Communication"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component is one of the most important component in a pulverized system: it manage all the\ncommunications with the neighbours' devices."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class DeviceCommunication : Communication<CommPayload> {\n  override val context: RabbitmqContext by inject()\n\n  private val connection: Connection by inject()\n\n  suspend fun initialize() {\n    // Initializations\n  }\n\n  override fun send(payload: CommPayload) {\n    val message = OutboundMessage("amq.fanout", "", Json.encodeToString(payload).toByteArray())\n    sender.send(Mono.just(message)).block()\n  }\n\n  override fun receive(): Flow<CommPayload> {\n    return receiver.consumeAutoAck(queue).asFlow().map<Delivery, CommPayload> {\n      Json.decodeFromString(it.body.decodeToString())\n    }.filter { it.deviceID != context.id.show() }\n  }\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DeviceComunication")," implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," interface which requires a type variable representing the type\nof the message the component should send and receive from the neighbours."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," interface define two methods ",(0,o.kt)("inlineCode",{parentName:"p"},"send()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"receive()")," which represents the operation of send a\nmessage to the neighbours and the operation of receiving messages from the neighbours, respectively."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Is responsibility of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component hold information about the topology of the network and how to reach\nthe neighbours.")),(0,o.kt)("p",null,'In this example we assume a "fully-connected topology" and since we use the ',(0,o.kt)("inlineCode",{parentName:"p"},"rabbitmq-platform")," package we rely on ",(0,o.kt)("em",{parentName:"p"},"\nRabbitMQ")," to reach all the neighbours using the pre-defined ",(0,o.kt)("em",{parentName:"p"},"exchange")," ",(0,o.kt)("inlineCode",{parentName:"p"},"amq.fanout")," which send the messages to all the\nbind queues. In this way we obtain a fully-connected network topology."),(0,o.kt)("h2",{id:"sensors"},"Sensors"),(0,o.kt)("p",null,"In this demo we use only one sensors, but of course, the framework give you the ability of define how many sensors you\nneed. First of all, we start to define how the sensor's information are represented."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"typealias SensorPayload = Double\n\n@Serializable\ndata class AllSensorsPayload(val deviceSensor: SensorPayload)\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The class representing the sensors' values ",(0,o.kt)("strong",{parentName:"p"},"MUST")," be annotated with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Serializable")," annotation since that class\nshould be reached by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour")," component.")),(0,o.kt)("p",null,"Next, we define a sensor. The implementation requires to implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sensor")," interface which requires information\nabout the values read by the sensor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class DeviceSensor : Sensor<SensorPayload> {\n  override fun sense(): SensorPayload = Random.nextDouble(0.0, 100.0)\n}\n")),(0,o.kt)("p",null,"In this demo we simulate a sensor with a random number between ",(0,o.kt)("inlineCode",{parentName:"p"},"0-100"),". The only method to implement is ",(0,o.kt)("inlineCode",{parentName:"p"},"sense()")," which\nreturn the sensed value from the sensor."),(0,o.kt)("p",null,'Now, we completed the step of writing all the pulverized components. Next, we will show ho to bind those components to\nthe "communicators" in order to make the system working.'))}m.isMDXComponent=!0}}]);