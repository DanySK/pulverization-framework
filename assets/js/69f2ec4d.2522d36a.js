"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[912],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8148:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:1},r="Create Pulverized Components",s={unversionedId:"tutorial-rabbitmq-platform/create-components",id:"tutorial-rabbitmq-platform/create-components",title:"Create Pulverized Components",description:"In this tutorial, we are going to create a simple pulverized application consisting of a device made up of the following",source:"@site/docs/tutorial-rabbitmq-platform/create-components.md",sourceDirName:"tutorial-rabbitmq-platform",slug:"/tutorial-rabbitmq-platform/create-components",permalink:"/pulverization-framework/docs/tutorial-rabbitmq-platform/create-components",draft:!1,editUrl:"https://github.com/nicolasfara/pulverization-framework/tree/master/docsite/docs/tutorial-rabbitmq-platform/create-components.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Tutorial - RabbitMQ platform",permalink:"/pulverization-framework/docs/category/tutorial---rabbitmq-platform"},next:{title:"Components Logic",permalink:"/pulverization-framework/docs/tutorial-rabbitmq-platform/components-logic"}},l={},p=[{value:"Behaviour",id:"behaviour",level:2},{value:"State",id:"state",level:2},{value:"Communication",id:"communication",level:2},{value:"Sensors",id:"sensors",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"create-pulverized-components"},"Create Pulverized Components"),(0,o.kt)("p",null,"In this tutorial, we are going to create a simple pulverized application consisting of a device made up of the following\ncomponents:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Communication")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Behaviour")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Sensors")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"State"))),(0,o.kt)("p",null,"The objective of the device is to read the ",(0,o.kt)("em",{parentName:"p"},"GPS")," position through the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sensors")," component, elaborate the distance\nbetween all neighbours through the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour"),"component and send his position via the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component to all\nthe neighbours."),(0,o.kt)("p",null,'In this scenario, we assume a "fully-connected topology" so that all the devices are connected.'),(0,o.kt)("h2",{id:"behaviour"},"Behaviour"),(0,o.kt)("p",null,"In this scenario, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour")," take the ",(0,o.kt)("em",{parentName:"p"},"GPS")," position given by the ",(0,o.kt)("strong",{parentName:"p"},"sensors")," component, take the positions of all\nhis neighbours and calculate the distance between all of them and save in the ",(0,o.kt)("strong",{parentName:"p"},"state")," the nearest device and his\ndistance."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class BehaviourComp : Behaviour<StateOps, NeighboursMessage, DeviceSensors, NoVal, Unit> {\n  override val context: Context by inject()\n\n  companion object {\n    private const val R = 6371\n    private const val ANGLE = 180.0\n  }\n\n  override fun invoke(\n    state: StateOps,\n    export: List<NeighboursMessage>,\n    sensedValues: DeviceSensors,\n  ): BehaviourOutput<StateOps, NeighboursMessage, NoVal, Unit> {\n    val (myLat, myLong) = sensedValues.gps\n    val distances = export.map { (device, location) ->\n      val dLat = (location.lat - myLat) * PI / ANGLE\n      val dLon = (location.long - myLong) * PI / ANGLE\n      val myLatRand = myLat * PI / ANGLE\n      val otherLatRand = location.lat * PI / ANGLE\n\n      val a = sin(dLat / 2) * sin(dLat / 2) +\n        sin(dLon / 2) * sin(dLon / 2) * cos(myLatRand) * cos(otherLatRand)\n      val c = 2 * atan2(sqrt(a), sqrt(1 - a))\n      device to R * c\n    }\n    val min = distances.minByOrNull { it.second }\n    return BehaviourOutput(\n      Distances(distances, min),\n      NeighboursMessage(context.deviceID, sensedValues.gps),\n      NoVal,\n      Unit,\n    )\n  }\n}\n")),(0,o.kt)("p",null,"The creation of the behaviour is made via the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behavior")," interface which requires the definitions\nof several type variables. The first one defines the shape of the state, in particular, the type should implement the\ninterface ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRepresentation"),". The second generic represents the communication payload and the given type should\nimplement the ",(0,o.kt)("inlineCode",{parentName:"p"},"CommunicationPayload")," interface. Moving on, the third generic specifies how all the sensor values are\ncollected; in this type should be available all the sensed values. The last two type-variable represent respectively the\nprescriptive actions and the function outcome. In this tutorial since we do not use any of these two parameters, we\nleave them empty."),(0,o.kt)("p",null,"The behaviour logic is implemented in the ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke()")," method. This method should return a ",(0,o.kt)("inlineCode",{parentName:"p"},"BehaviourOutput")," which consist\nof: a new state, the communication for the neighbours, prescriptive actions, and an outcome."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Each ",(0,o.kt)("inlineCode",{parentName:"p"},"PulverizedComponent")," holds a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," that contains some information about the specific environment in which the\ncomponent is executed. At the time of writing the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," only holds the ",(0,o.kt)("inlineCode",{parentName:"p"},"deviceID"),".")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Since the Kotlin serialization doesn't allow the serialization of the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Nothing"),", a special object is available to\novercome this issue. The object is ",(0,o.kt)("inlineCode",{parentName:"p"},"NoVal")," which represents the absence of value. Similarly, ",(0,o.kt)("inlineCode",{parentName:"p"},"NoState")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"NoComm")," are\nobject which represents the absence of a state and the absence of communication, respectively.")),(0,o.kt)("h2",{id:"state"},"State"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," in this scenario holds information about the distances from all the neighbours and the nearest neighbour\nwith his distance."),(0,o.kt)("p",null,"To define a new state we should, first of all, define how the state is composed. To do that is useful to define the\nrepresentation of the state through a ",(0,o.kt)("inlineCode",{parentName:"p"},"data class")," which implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRepresentation")," interface."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Serializable\nsealed interface StateOps : StateRepresentation\n\n@Serializable\ndata class Distances(\n  val distances: List<Pair<String, Double>>,\n  val nearest: Pair<String, Double>?\n) : StateOps\n\n@Serializable\ndata class Query(val query: String) : StateOps\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The representation above as an ADT (Algebraic Data Type) enable to define a custom behaviour based on the received\nmessage. For example in this case ",(0,o.kt)("inlineCode",{parentName:"p"},"Dinstance")," represents the effective state, but with ",(0,o.kt)("inlineCode",{parentName:"p"},"Query"),' we can "query" the state.')),(0,o.kt)("p",null,"Once the state representation is defined we need to create the state component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class StateComp : State<StateOps> {\n  override val context: Context by inject()\n\n  private var state = Distances(emptyList(), null)\n\n  override fun get(): StateOps = state\n\n  override fun update(newState: StateOps): StateOps {\n    val tmp = state\n    when (newState) {\n      is Distances -> state = newState\n      is Query -> println("Query received: ${newState.query}")\n    }\n    return tmp\n  }\n}\n')),(0,o.kt)("p",null,"Only two methods are to be implemented ",(0,o.kt)("inlineCode",{parentName:"p"},"get()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"update()")," which respectively return the current state and update the\nstate with a new one."),(0,o.kt)("h2",{id:"communication"},"Communication"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component is one of the most important components in a pulverized system: it manages all the\ncommunications with the neighbours' devices."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'class CommunicationComp : Communication<NeighboursMessage> {\n  override val context: Context by inject()\n\n  private lateinit var sender: Sender\n  private lateinit var receiver: Receiver\n\n  private val exchange = "amq.fanout"\n  private lateinit var queue: String\n\n  override suspend fun initialize() {\n    // Initialization\n  }\n\n  override suspend fun send(payload: NeighboursMessage) {\n    val message = OutboundMessage(exchange, "", Json.encodeToString(payload).toByteArray())\n    sender.send(Mono.just(message)).awaitSingleOrNull()\n  }\n\n  override fun receive(): Flow<NeighboursMessage> =\n    receiver.consumeAutoAck(queue)\n      .asFlow()\n      .map { Json.decodeFromString(it.body.decodeToString()) }\n\n  override suspend fun finalize() {\n    sender.close()\n    receiver.close()\n  }\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CommunicationComp")," implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," interface that requires a type variable representing the type\nof the message, the component should send and receive from the neighbours."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," interface define two methods ",(0,o.kt)("inlineCode",{parentName:"p"},"send()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"receive()")," which represents the operation of send a\nmessage to the neighbours and the operation of receiving messages from the neighbours, respectively."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Is responsibility of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Communication")," component hold information about the topology of the network and how to reach\nthe neighbours.")),(0,o.kt)("p",null,'In this example, we assume a "fully-connected topology" and, since we use the ',(0,o.kt)("inlineCode",{parentName:"p"},"rabbitmq-platform")," package, we rely on ",(0,o.kt)("em",{parentName:"p"},"\nRabbitMQ")," to reach all the neighbours using the pre-defined ",(0,o.kt)("em",{parentName:"p"},"exchange")," ",(0,o.kt)("inlineCode",{parentName:"p"},"amq.fanout")," that sends the messages to all the\nbind queues. In this way, we obtain a fully-connected network topology."),(0,o.kt)("h2",{id:"sensors"},"Sensors"),(0,o.kt)("p",null,"In this demo we use only one sensor, but of course, the framework give you the ability to define how many sensors you\nneed. First of all, we start to define how the sensor's information are represented."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Serializable\ndata class Gps(val long: Double, val lat: Double)\n\n@Serializable\ndata class DeviceSensors(val gps: Gps)\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The class representing the sensors' values ",(0,o.kt)("strong",{parentName:"p"},"MUST")," be annotated with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Serializable")," annotation since that class\nshould be reached by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Behaviour")," component.")),(0,o.kt)("p",null,"Next, we define a sensor. The implementation requires implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sensor")," interface that requires information\nabout the values read by the sensor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class GpsSensor : Sensor<Gps> {\n  override fun sense(): Gps = Gps(Random.nextDouble(-180.0, 180.0), Random.nextDouble(-90.0, 90.0))\n}\n")),(0,o.kt)("p",null,"In this demo, we simulate a ",(0,o.kt)("em",{parentName:"p"},"GPS")," sensor. The only method to implement is ",(0,o.kt)("inlineCode",{parentName:"p"},"sense()")," which return the sensed value from\nthe sensor."),(0,o.kt)("p",null,"In the end is necessarily to create the ",(0,o.kt)("inlineCode",{parentName:"p"},"SensorsContainer")," a class which hold all the sensors of a device."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LocalizationSensor : SensorsContainer() {\n  override val context: Context by inject()\n\n  override suspend fun initialize() {\n    this += GpsSensor()\n  }\n}\n")),(0,o.kt)("p",null,"Now, we completed the step of writing all the pulverized components."))}m.isMDXComponent=!0}}]);